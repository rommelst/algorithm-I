# Course introduction -- Union-Find - Analysis of Algorithms

##### About this week.
>**Union-Find**: we illustrate our basic approach to developing and analyzing algorithms by considering the dynamic connectivity problem. We introduce the union−find data type and consider several implementations (quick find, quick union, weighted quick union, and weighted quick union with path compression). Finally, we apply the union−find data type to the percolation problem from physical chemistry.

> **Analysis of Algorithms**: The basis of our approach for analyzing the performance of algorithms is the scientific method. We begin by performing computational experiments to measure the running times of our programs. We use these measurements to develop hypotheses about performance. Next, we create mathematical models to explain their behavior. Finally, we consider analyzing the memory usage of our Java programs.

##### Key Concepts
> - Apply the union-find data type to solve problems in science,
> engineering, and industry.
> - Define the union-find (or disjoint sets) data type.
> - Compare the performance of different algorithms for the union-find data type.
> - Design different algorithms (quick find, quick union, weighted quick union, path compression) - for the union-find data type.
> - Develop Java implementations of different algorithms for the union-find data type.
> - Use the parent-link representation to represent tree data structures.

## Programming Assignement

### Score
![Partial printscreen from coursera](./image/grade.png)
:heavy_check_mark: :trophy:

### Timing
![Partial printscreen from coursera](./image/timing_test04.png)

### Memory
![Partial printscreen from coursera](./image/assessment_summary.png)
![Partial printscreen from coursera](./image/memory_test1a1d_and_test2.png)

##### Bônus for solving backwash problem without second Weighetd Union Find object.

